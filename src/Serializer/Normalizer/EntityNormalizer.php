<?php

namespace Anboo\ApiBundle\Serializer\Normalizer;

use Doctrine\ORM\EntityManagerInterface;
use Symfony\Component\PropertyAccess\PropertyAccessorInterface;
use Symfony\Component\PropertyInfo\PropertyTypeExtractorInterface;
use Symfony\Component\Serializer\Exception\LogicException;
use Symfony\Component\Serializer\Mapping\ClassDiscriminatorResolverInterface;
use Symfony\Component\Serializer\Mapping\Factory\ClassMetadataFactoryInterface;
use Symfony\Component\Serializer\NameConverter\NameConverterInterface;
use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;

/**
 * Class EntityNormalizer
 */
class EntityNormalizer extends ObjectNormalizer
{
    /** @var EntityManagerInterface */
    private $entityManager;

    /** @var string[] */
    protected $ignoredAttributes = ['lazyPropertiesDefaults'];

    /**
     * EntityNormalizer constructor.
     * @param EntityManagerInterface $entityManager
     * @param ClassMetadataFactoryInterface|null $classMetadataFactory
     * @param NameConverterInterface|null $nameConverter
     * @param PropertyAccessorInterface|null $propertyAccessor
     * @param PropertyTypeExtractorInterface|null $propertyTypeExtractor
     * @param ClassDiscriminatorResolverInterface|null $classDiscriminatorResolver
     * @param callable|null $objectClassResolver
     * @param array $defaultContext
     */
    public function __construct(
        EntityManagerInterface $entityManager,
        ?ClassMetadataFactoryInterface $classMetadataFactory = null,
        ?NameConverterInterface $nameConverter = null,
        ?PropertyAccessorInterface $propertyAccessor = null,
        ?PropertyTypeExtractorInterface $propertyTypeExtractor = null,
        ?ClassDiscriminatorResolverInterface $classDiscriminatorResolver = null,
        callable $objectClassResolver = null,
        array $defaultContext = []
    ) {
        $this->entityManager = $entityManager;

        $this->defaultContext[self::IGNORED_ATTRIBUTES] = $this->defaultContext[self::IGNORED_ATTRIBUTES] ?? [];
        $this->defaultContext[self::IGNORED_ATTRIBUTES][] = 'lazyPropertiesDefaults';
        $this->defaultContext[self::IGNORED_ATTRIBUTES][] = 'isEqualTo';

        parent::__construct($classMetadataFactory, $nameConverter, $propertyAccessor, $propertyTypeExtractor, $classDiscriminatorResolver, $objectClassResolver, $defaultContext);
    }

    /**
     * @param $data
     * @param $class
     * @param null $format
     * @param array $context
     * @return object|null
     */
    public function denormalize($data, $class, $format = null, array $context = [])
    {
        $entity = $this->entityManager->find($class, $data['id']);

//        if (!$entity) {
//            $dataClass = explode('\\', $class);
//            $class = array_pop($dataClass);
//
//            throw new \RuntimeException(sprintf('%s with id %s not found', $class, $data['id']));
//        }

        return $entity;
    }

    /**
     * @param $data
     * @param $type
     * @param null $format
     * @return bool
     */
    public function supportsDenormalization($data, $type, $format = null)
    {
        return strpos($type, 'App\\Entity\\') === 0 && isset($data['id']);
    }

    protected function getAttributes($object, $format = null, array $context)
    {
        return parent::getAttributes($object, $format, $context); // TODO: Change the autogenerated stub
    }

    protected function getAllowedAttributes($classOrObject, array $context, $attributesAsString = false)
    {
        $allowExtraAttributes = $context[self::ALLOW_EXTRA_ATTRIBUTES] ?? $this->defaultContext[self::ALLOW_EXTRA_ATTRIBUTES];
        if (!$this->classMetadataFactory) {
            if (!$allowExtraAttributes) {
                throw new LogicException(sprintf('A class metadata factory must be provided in the constructor when setting "%s" to false.', self::ALLOW_EXTRA_ATTRIBUTES));
            }

            return false;
        }

        $tmpGroups = $context[self::GROUPS] ?? $this->defaultContext[self::GROUPS] ?? null;
        $groups = (\is_array($tmpGroups) || is_scalar($tmpGroups)) ? (array) $tmpGroups : false;
        if (false === $groups && $allowExtraAttributes) {
            return false;
        }

        $extractedAttributes = $this->extractAttributes($classOrObject);

        $attributesMetadata = $this->classMetadataFactory->getMetadataFor($classOrObject)->getAttributesMetadata();
        $allowedAttributes = [];

        foreach ($extractedAttributes as $extractedAttribute) {
            foreach ($attributesMetadata as $attributeMetadata) {
                $name = $attributeMetadata->getName();

                if ($extractedAttribute !== $name) {
                    continue;
                }

                if (
                    (false === $groups || !$attributeMetadata->getGroups() || array_intersect($attributeMetadata->getGroups(), $groups)) &&
                    $this->isAllowedAttribute($classOrObject, $name, null, $context)
                ) {
                    $allowedAttributes[] = $attributesAsString ? $name : $attributeMetadata;
                }
            }
        }

        return $allowedAttributes;
    }
}